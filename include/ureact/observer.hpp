//
//         Copyright (C) 2014-2017 Sebastian Jeckel.
//         Copyright (C) 2020-2023 Krylov Yaroslav.
//
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef UREACT_OBSERVER_HPP
#define UREACT_OBSERVER_HPP

#include <ureact/ureact.hpp>

UREACT_BEGIN_NAMESPACE

/*!
 * @brief Observer functions can return values of this type to control further processing.
 */
enum class observer_action
{
    next,           ///< Continue observing
    stop_and_detach ///< Stop observing
};

/*!
 * @brief Shared pointer like object that holds a strong reference to the observed subject
 *
 *  An instance of this class provides a unique handle to an observer which can
 *  be used to detach it explicitly. It also holds a strong reference to
 *  the observed subject, so while it exists the subject and therefore
 *  the observer will not be destroyed.
 *
 *  If the handle is destroyed without calling detach(), the lifetime of
 *  the observer is tied to the subject.
 */
class observer final
{
private:
    using subject_ptr_t = std::shared_ptr<detail::observable_node>;
    using Node = detail::observer_node;

public:
    UREACT_MAKE_NONCOPYABLE( observer );
    UREACT_MAKE_MOVABLE( observer );

    /*!
     * @brief Default constructor
     */
    observer() = default;

    /*!
     * @brief Construct from the give node and a subject.
     * 
     * Not intended to be used directly. Use `observe()` instead.
     */
    observer( Node* node, subject_ptr_t subject )
        : m_node( node )
        , m_subject( std::move( subject ) )
    {}

    /*!
     * @brief Manually detaches the linked observer node from its subject
     */
    void detach()
    {
        assert( is_valid() );
        m_subject->unregister_observer( m_node );
    }

    /*!
     * @brief Tests if this instance is linked to a node
     */
    UREACT_WARN_UNUSED_RESULT bool is_valid() const
    {
        return m_node != nullptr;
    }

private:
    /// Owned by subject
    Node* m_node = nullptr;

    /// While the observer handle exists, the subject is not destroyed
    subject_ptr_t m_subject = nullptr;
};

UREACT_END_NAMESPACE

#endif //UREACT_OBSERVER_HPP
